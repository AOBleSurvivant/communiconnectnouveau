#!/usr/bin/env node

/**
 * üîó Tests d'Int√©gration Compl√®te - CommuniConnect
 * 
 * Ce script teste l'int√©gration compl√®te de Firebase :
 * - Configuration client/serveur
 * - Communication entre services
 * - Gestion des erreurs
 * - Performance globale
 */

const fs = require('fs');
const path = require('path');

// Couleurs pour les logs
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logHeader(title) {
  log(`\n${'='.repeat(60)}`, 'cyan');
  log(`üîó ${title}`, 'bright');
  log(`${'='.repeat(60)}`, 'cyan');
}

function logTest(testName, result, details = '') {
  const status = result ? '‚úÖ PASS' : '‚ùå FAIL';
  const color = result ? 'green' : 'red';
  log(`  ${status} ${testName}`, color);
  if (details) {
    log(`    ${details}`, 'yellow');
  }
}

// Tests d'int√©gration client-serveur
function testClientServerIntegration() {
  logHeader('INT√âGRATION CLIENT-SERVEUR');

  let allTestsPassed = true;

  // Test 1: V√©rifier la coh√©rence des configurations
  const clientFirebasePath = 'client/src/services/firebase.js';
  const serverFirebasePath = 'server/config/firebase.js';
  
  if (fs.existsSync(clientFirebasePath) && fs.existsSync(serverFirebasePath)) {
    const clientContent = fs.readFileSync(clientFirebasePath, 'utf8');
    const serverContent = fs.readFileSync(serverFirebasePath, 'utf8');
    
    const clientHasProjectId = clientContent.includes('communiconnect-46934');
    const serverHasProjectId = serverContent.includes('communiconnect-46934') || serverContent.includes('process.env.FIREBASE_PROJECT_ID');
    
    logTest('Project ID coh√©rent client/serveur', clientHasProjectId && serverHasProjectId);
    
    if (!clientHasProjectId || !serverHasProjectId) {
      allTestsPassed = false;
    }
  }

  // Test 2: V√©rifier la communication des tokens
  const pushServicePath = 'client/src/services/pushNotificationService.js';
  const serverPushServicePath = 'server/services/pushNotificationService.js';
  
  if (fs.existsSync(pushServicePath) && fs.existsSync(serverPushServicePath)) {
    const clientContent = fs.readFileSync(pushServicePath, 'utf8');
    const serverContent = fs.readFileSync(serverPushServicePath, 'utf8');
    
    const clientSendsToken = clientContent.includes('sendTokenToServer');
    const serverReceivesToken = serverContent.includes('registerToken') || serverContent.includes('fcmToken');
    
    logTest('Client envoie tokens au serveur', clientSendsToken);
    logTest('Serveur re√ßoit et stocke tokens', serverReceivesToken);
    
    if (!clientSendsToken || !serverReceivesToken) {
      allTestsPassed = false;
    }
  }

  return allTestsPassed;
}

// Tests de configuration d'environnement
function testEnvironmentConfiguration() {
  logHeader('CONFIGURATION ENVIRONNEMENT');

  let allTestsPassed = true;

  // Test 1: V√©rifier les fichiers d'environnement
  const envFiles = [
    'client/.env.example',
    'server/.env.example',
    'client/env.production.example',
    'server/env.production.example'
  ];

  envFiles.forEach(file => {
    if (fs.existsSync(file)) {
      const content = fs.readFileSync(file, 'utf8');
      const hasFirebaseVars = content.includes('FIREBASE') || content.includes('REACT_APP_FIREBASE');
      
      logTest(`Variables Firebase dans ${path.basename(file)}`, hasFirebaseVars);
      
      if (!hasFirebaseVars) allTestsPassed = false;
    } else {
      // Ignorer les fichiers .env.example s'ils n'existent pas (optionnels)
      if (file.includes('.env.example')) {
        logTest(`Fichier ${path.basename(file)} (optionnel)`, true, 'Fichier optionnel - ignor√©');
      } else {
        logTest(`Fichier ${path.basename(file)} existe`, false);
        allTestsPassed = false;
      }
    }
  });

  // Test 2: V√©rifier la configuration de production
  const prodEnvFiles = [
    'client/env.production.example',
    'server/env.production.example'
  ];

  prodEnvFiles.forEach(file => {
    if (fs.existsSync(file)) {
      const content = fs.readFileSync(file, 'utf8');
      const hasProductionConfig = content.includes('production') || content.includes('PROD');
      
      logTest(`Configuration production dans ${path.basename(file)}`, hasProductionConfig);
      
      if (!hasProductionConfig) allTestsPassed = false;
    }
  });

  return allTestsPassed;
}

// Tests de s√©curit√©
function testSecurity() {
  logHeader('S√âCURIT√â INT√âGRATION');

  let allTestsPassed = true;

  // Test 1: V√©rifier la gestion des cl√©s sensibles
  const clientFirebasePath = 'client/src/services/firebase.js';
  const serverFirebasePath = 'server/config/firebase.js';
  
  if (fs.existsSync(clientFirebasePath)) {
    const content = fs.readFileSync(clientFirebasePath, 'utf8');
    const hasApiKey = content.includes('AIzaSyDXe99GAQ3mnXE9M-j_vacRZEKKuSlkMQc');
    const hasProjectId = content.includes('communiconnect-46934');
    
    // C'est normal d'avoir les cl√©s publiques c√¥t√© client
    logTest('Cl√©s Firebase c√¥t√© client (normal)', hasApiKey && hasProjectId, 'Cl√©s publiques autoris√©es');
  }

  if (fs.existsSync(serverFirebasePath)) {
    const content = fs.readFileSync(serverFirebasePath, 'utf8');
    const usesEnvVars = content.includes('process.env.FIREBASE') || content.includes('process.env.FIREBASE_SERVICE_ACCOUNT_KEY');
    
    logTest('Serveur utilise variables d\'environnement', usesEnvVars);
    
    if (!usesEnvVars) allTestsPassed = false;
  }

  // Test 2: V√©rifier la validation des tokens
  const serverPushServicePath = 'server/services/pushNotificationService.js';
  if (fs.existsSync(serverPushServicePath)) {
    const content = fs.readFileSync(serverPushServicePath, 'utf8');
    const validatesTokens = content.includes('invalid-registration-token') || content.includes('registration-token-not-registered');
    const removesInvalidTokens = content.includes('removeInvalidToken') || content.includes('$unset');
    
    logTest('Validation des tokens c√¥t√© serveur', validatesTokens);
    logTest('Suppression des tokens invalides', removesInvalidTokens);
    
    if (!validatesTokens || !removesInvalidTokens) allTestsPassed = false;
  }

  return allTestsPassed;
}

// Tests de performance
function testPerformance() {
  logHeader('PERFORMANCE INT√âGRATION');

  let allTestsPassed = true;

  // Test 1: V√©rifier la taille des bundles
  const filesToCheck = [
    'client/src/services/firebase.js',
    'client/src/services/pushNotificationService.js',
    'client/public/firebase-messaging-sw.js',
    'server/config/firebase.js',
    'server/services/pushNotificationService.js'
  ];

  let totalSize = 0;
  filesToCheck.forEach(file => {
    if (fs.existsSync(file)) {
      const stats = fs.statSync(file);
      const sizeKB = Math.round(stats.size / 1024);
      totalSize += sizeKB;
      
      const isReasonable = sizeKB < 100; // Moins de 100KB par fichier
      logTest(`Taille ${path.basename(file)} (${sizeKB}KB)`, isReasonable, `${sizeKB}KB`);
      
      if (!isReasonable) allTestsPassed = false;
    }
  });

  const isTotalReasonable = totalSize < 500; // Moins de 500KB total
  logTest(`Taille totale Firebase (${totalSize}KB)`, isTotalReasonable, `${totalSize}KB`);
  
  if (!isTotalReasonable) allTestsPassed = false;

  // Test 2: V√©rifier l'optimisation
  const pushServicePath = 'client/src/services/pushNotificationService.js';
  if (fs.existsSync(pushServicePath)) {
    const content = fs.readFileSync(pushServicePath, 'utf8');
    
    const hasLazyLoading = content.includes('this.isInitialized') || content.includes('this.isSupported');
    const hasEfficientChecks = content.includes('if (!this.isSupported') || content.includes('if (!this.isInitialized');
    const hasSingleton = content.includes('// Instance singleton');
    
    logTest('Chargement diff√©r√©', hasLazyLoading);
    logTest('V√©rifications efficaces', hasEfficientChecks);
    logTest('Pattern singleton', hasSingleton);
    
    if (!hasLazyLoading || !hasEfficientChecks || !hasSingleton) {
      allTestsPassed = false;
    }
  }

  return allTestsPassed;
}

// Tests de compatibilit√©
function testCompatibility() {
  logHeader('COMPATIBILIT√â INT√âGRATION');

  let allTestsPassed = true;

  // Test 1: V√©rifier la compatibilit√© des versions
  const clientPackagePath = 'client/package.json';
  const serverPackagePath = 'server/package.json';
  
  if (fs.existsSync(clientPackagePath)) {
    const packageJson = JSON.parse(fs.readFileSync(clientPackagePath, 'utf8'));
    const firebaseVersion = packageJson.dependencies?.firebase;
    
    if (firebaseVersion) {
      const version = firebaseVersion.replace('^', '').replace('~', '');
      const majorVersion = parseInt(version.split('.')[0]);
      const isCompatible = majorVersion >= 9;
      
      logTest(`Version Firebase client (${version})`, isCompatible, `Version: ${version}`);
      
      if (!isCompatible) allTestsPassed = false;
    }
  }

  if (fs.existsSync(serverPackagePath)) {
    const packageJson = JSON.parse(fs.readFileSync(serverPackagePath, 'utf8'));
    const firebaseAdminVersion = packageJson.dependencies?.['firebase-admin'];
    
    if (firebaseAdminVersion) {
      const version = firebaseAdminVersion.replace('^', '').replace('~', '');
      const majorVersion = parseInt(version.split('.')[0]);
      const isCompatible = majorVersion >= 11;
      
      logTest(`Version Firebase Admin (${version})`, isCompatible, `Version: ${version}`);
      
      if (!isCompatible) allTestsPassed = false;
    }
  }

  // Test 2: V√©rifier la compatibilit√© du service worker
  const swPath = 'client/public/firebase-messaging-sw.js';
  if (fs.existsSync(swPath)) {
    const content = fs.readFileSync(swPath, 'utf8');
    
    const usesCompat = content.includes('firebase-app-compat.js') && content.includes('firebase-messaging-compat.js');
    const hasModernFeatures = content.includes('onBackgroundMessage') && content.includes('notificationclick');
    const hasFallbacks = content.includes('clients.openWindow') || content.includes('clients.focus');
    
    logTest('Service Worker utilise compatibilit√©', usesCompat);
    logTest('Service Worker a fonctionnalit√©s modernes', hasModernFeatures);
    logTest('Service Worker a fallbacks', hasFallbacks);
    
    if (!usesCompat || !hasModernFeatures || !hasFallbacks) {
      allTestsPassed = false;
    }
  }

  return allTestsPassed;
}

// Tests de documentation
function testDocumentation() {
  logHeader('DOCUMENTATION INT√âGRATION');

  let allTestsPassed = true;

  // Test 1: V√©rifier la documentation
  const docsFiles = [
    'FIREBASE_SETUP.md',
    'FIREBASE_NEXT_STEPS.md'
  ];

  docsFiles.forEach(file => {
    const exists = fs.existsSync(file);
    logTest(`Documentation ${file}`, exists);
    
    if (!exists) allTestsPassed = false;
  });

  // Test 2: V√©rifier les commentaires dans le code
  const codeFiles = [
    'client/src/services/firebase.js',
    'client/src/services/pushNotificationService.js',
    'client/public/firebase-messaging-sw.js',
    'server/config/firebase.js'
  ];

  codeFiles.forEach(file => {
    if (fs.existsSync(file)) {
      const content = fs.readFileSync(file, 'utf8');
      const hasComments = content.includes('//') || content.includes('/*');
      const hasHeaderComment = content.includes('Configuration Firebase') || content.includes('Service Worker') || content.includes('PushNotificationService');
      
      logTest(`Commentaires dans ${path.basename(file)}`, hasComments);
      logTest(`Commentaire d'en-t√™te dans ${path.basename(file)}`, hasHeaderComment);
      
      if (!hasComments || !hasHeaderComment) allTestsPassed = false;
    }
  });

  return allTestsPassed;
}

// Test principal
function runAllIntegrationTests() {
  logHeader('D√âMARRAGE DES TESTS D\'INT√âGRATION COMPL√àTE');
  
  const startTime = Date.now();
  let totalTests = 0;
  let passedTests = 0;

  const testSuites = [
    { name: 'Client-Serveur', test: testClientServerIntegration },
    { name: 'Environnement', test: testEnvironmentConfiguration },
    { name: 'S√©curit√©', test: testSecurity },
    { name: 'Performance', test: testPerformance },
    { name: 'Compatibilit√©', test: testCompatibility },
    { name: 'Documentation', test: testDocumentation }
  ];

  testSuites.forEach(suite => {
    try {
      const result = suite.test();
      if (result) {
        passedTests++;
        log(`‚úÖ ${suite.name}: TOUS LES TESTS PASS√âS`, 'green');
      } else {
        log(`‚ùå ${suite.name}: CERTAINS TESTS √âCHOU√âS`, 'red');
      }
      totalTests++;
    } catch (error) {
      log(`üí• ${suite.name}: ERREUR - ${error.message}`, 'red');
      totalTests++;
    }
  });

  const endTime = Date.now();
  const duration = Math.round((endTime - startTime) / 1000);

  logHeader('R√âSULTATS FINAUX INT√âGRATION');
  log(`‚è±Ô∏è  Dur√©e totale: ${duration}s`, 'cyan');
  log(`üìä Tests pass√©s: ${passedTests}/${totalTests}`, passedTests === totalTests ? 'green' : 'yellow');
  log(`üìà Taux de r√©ussite: ${Math.round((passedTests / totalTests) * 100)}%`, passedTests === totalTests ? 'green' : 'yellow');

  if (passedTests === totalTests) {
    log('\nüéâ TOUS LES TESTS D\'INT√âGRATION SONT PASS√âS !', 'bright');
    log('üîó Votre int√©gration Firebase est compl√®te et pr√™te !', 'green');
  } else {
    log('\n‚ö†Ô∏è  CERTAINS TESTS ONT √âCHOU√â', 'yellow');
    log('üîß Consultez les d√©tails ci-dessus pour corriger les probl√®mes', 'yellow');
  }

  return passedTests === totalTests;
}

// Ex√©cuter les tests
if (require.main === module) {
  const success = runAllIntegrationTests();
  process.exit(success ? 0 : 1);
}

module.exports = {
  testClientServerIntegration,
  testEnvironmentConfiguration,
  testSecurity,
  testPerformance,
  testCompatibility,
  testDocumentation,
  runAllIntegrationTests
}; 